use std::str::FromStr;

use chainhook_sdk::utils::Context;
use ordinals::{Edict, Etching, SpacedRune, Terms};
use postgres::{Client, Error, NoTls};

pub fn init_db(ctx: &Context) -> Result<Client, Error> {
    let mut client = Client::connect("host=localhost user=postgres", NoTls)?;
    client.batch_execute(
        "
        CREATE TABLE IF NOT EXISTS runes (
            id                      BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            name                    TEXT NOT NULL UNIQUE,
            number                  BIGINT NOT NULL DEFAULT 0,
            block_height            BIGINT NOT NULL,
            tx_index                BIGINT NOT NULL,
            tx_id                   TEXT NOT NULL,
            divisibility            SMALLINT,
            premine                 NUMERIC,
            symbol                  TEXT,
            terms_amount            NUMERIC,
            terms_cap               NUMERIC,
            terms_height_start      BIGINT,
            terms_height_end        BIGINT,
            terms_offset_start      BIGINT,
            terms_offset_end        BIGINT,
            turbo                   BOOLEAN NOT NULL,
            minted                  NUMERIC NOT NULL DEFAULT 0,
            burned                  NUMERIC NOT NULL DEFAULT 0
        );
        CREATE TYPE ledger_operation AS ENUM ('mint', 'burn', 'send', 'receive');
        CREATE TABLE IF NOT EXISTS ledger (
            rune_id                 BIGINT NOT NULL,
            block_height            BIGINT NOT NULL,
            tx_index                BIGINT NOT NULL,
            tx_id                   TEXT NOT NULL,
            address                 TEXT NOT NULL,
            amount                  NUMERIC NOT NULL,
            operation               ledger_operation NOT NULL
        );
    ",
    )?;
    // Insert default UNCOMMON•GOODS rune
    let rune = SpacedRune::from_str("UNCOMMON•GOODS").unwrap();
    let _ = insert_etching(
        &Etching {
            divisibility: Some(0),
            premine: Some(0),
            rune: Some(rune.rune),
            spacers: Some(rune.spacers),
            symbol: Some('⧉'),
            terms: Some(Terms {
                amount: Some(1),
                cap: Some(u128::max_value()),
                height: (Some(840000), Some(1050000)),
                offset: (None, None),
            }),
            turbo: false,
        },
        1,
        0,
        &"".to_string(),
        &mut client,
        ctx,
    );
    Ok(client)
}

pub fn insert_etching(
    etching: &Etching,
    block_height: u64,
    tx_index: u32,
    tx_id: &String,
    client: &mut Client,
    ctx: &Context,
) -> Result<bool, Error> {
    let Some(rune_display) = etching.rune.map(|r| r.to_string()) else {
        println!("etching.rune = null");
        return Ok(false);
    };
    let divisibility = etching.divisibility.map(|r| r.to_string());
    let premine = etching.premine.map(|p| p.to_string());
    let symbol = etching.symbol.map(|i| i.to_string());
    let mut terms_amount = None;
    let mut terms_cap = None;
    let mut terms_height_start = None;
    let mut terms_height_end = None;
    let mut terms_offset_start = None;
    let mut terms_offset_end = None;
    if let Some(terms) = etching.terms {
        terms_amount = terms.amount.map(|i| i.to_string());
        terms_cap = terms.cap.map(|i| i.to_string());
        terms_height_start = terms.height.0.map(|i| i.to_string());
        terms_height_end = terms.height.1.map(|i| i.to_string());
        terms_offset_start = terms.offset.0.map(|i| i.to_string());
        terms_offset_end = terms.offset.1.map(|i| i.to_string());
    }

    let res = client.execute(
        "INSERT INTO runes
        (name, block_height, tx_index, tx_id, divisibility, premine, symbol, terms_amount, terms_cap, terms_height_start,
         terms_height_end, terms_offset_start, terms_offset_end, turbo)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
        ON CONFLICT (name) DO NOTHING",
        &[
            &rune_display,
            &block_height.to_string(),
            &tx_index.to_string(),
            &tx_id,
            &divisibility,
            &premine,
            &symbol,
            &terms_amount,
            &terms_cap,
            &terms_height_start,
            &terms_height_end,
            &terms_offset_start,
            &terms_offset_end,
            &etching.turbo
        ],
    );

    if let Err(e) = res {
        error!(ctx.expect_logger(), "Error inserting: {}", e.to_string(),);
    }
    Ok(true)
}

// pub fn insert_edict(
//     edict: &Edict,
//     block_height: u64,
//     tx_index: u32,
//     tx_id: &String,
//     client: &mut Client,
//     ctx: &Context,
// ) -> Result<bool, Error> {
//     //
// }
